# -*- coding: utf-8 -*-
"""Adaptive_Integration.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/WereszczynskiClasses/assignment-week-7-andrguardia/blob/main/Adaptive_Integration.ipynb

#Adaptive Integration

Consider the integral:

$
E\left(x\right) = \int_0^x e^{-t^2}dt
$

There is no known way to perform this integral analytically, so numerical approaches are the only way to solve it.

##A. 

Consider the function 
$
E\left(x=2\right) = \int_0^2 e^{-t^2}dt
$

Write a program that computes this integral with both the adaptive trapezoidal rule and the adaptive Simpson's rule to an accuracy of $10^{-8}$.  Make a log/log plot of the number of slices on the x-axis and the accuracy on the y-axis.
"""

import numpy as np
import matplotlib.pyplot as plt

def f(x):
  return np.exp(-1*x**2)

a = 0.0 #Lower Bound
b = 2.0 #Upper Bound
error = 1.0e-8 #error threshold
N_1 = 10 #Initial number of slices
I = np.array([0.0]) 
N = [N_1/2] 
err = [2*error] 
k = 0 
while err[k]>error:  
  k += 1  
  N.append(int(N[k-1]*2)) 
  h=(b-a)/N[k]  
  x = np.linspace(a,b,N[k]+1,endpoint=True) 
  y = f(x) 
  integral = h*0.5*(y[0]+y[-1]) 
  for r in range(1,N[k]):
    integral += h * y[r]
  I=np.append(I,integral) 
  err.append(1/3*np.abs(I[k]-I[k-1])) 

print("For an accuracy of",error, " N = ",N[k], "slices are required.  The final integral value is: ",I[k])

plt.loglog(N[1:],err[1:],'r*-')
plt.xlabel("Number of slices")
plt.ylabel("Error")
plt.title("Error vs Number of Slices")
plt.show()

error = 1.0e-8
I = np.array([0.0])
N = [N_init/2] 
err = [2*error] 
i = 0 
while err[i]>error:  
  i += 1  #increase counter 
  N.append(int(N[i-1]*2)) #add slice number to slices array
  h = (b-a)/N[i] #calculate interval width
  x = np.linspace(a,b,N[i]+1)
  y = f(x)
  approx = h/3 * np.sum(y[0:-1:2] + 4*y[1::2] + y[2::2]) #approimating integral value
  I=np.append(I,approx) 
  err.append(1.0/15.0*np.abs(I[i]-I[i-1])) #add loop tolerance to the loop array

print("For an accuracy of",tolerance, " N = ",N[i], "slices are required.  The final integral value is: ",I[i])
plt.loglog(N[1:],err[1:],'r*-') #plot the results
plt.xlabel("Number of slices")
plt.ylabel("Error")
plt.title("Simpson's Method Slices vs Error")
plt.show()

"""##B

When you are convinced your program is working, extend it further to make a graph of $E\left(x\right)$ as a function of $x$ from $0\leq x \leq 10$.  Make sure each integral is calculated with an accuracy of $10^{-8}$.
"""

#Define the function E(x) as a the integral of the function f for a range whose upper bound is defined by x
def E(b): 
  a = 0
  error = 1.0e-8
  I = np.array([0.0])
  N = [N_init/2] 
  err = [2*error] 
  i = 0 
  while tol[i]>error:  
    i += 1  
    N.append(int(N[i-1]*2))
    h = (b-a)/N[i]
    x = np.linspace(a,b,N[i]+1)
    y = f(x)
    approx = h/3 * np.sum(y[0:-1:2] + 4*y[1::2] + y[2::2])
    I=np.append(I,approx) 
    err.append(1/15*np.abs(I[i]-I[i-1])) 
  return I[i]

#Calculate the y values of  the integral for the given range
q = []
for k in range(0,11):
  q.append(E(k))
print(q)

#Now plotting the function E(x) against the given range
w = range(0,11)

plt.plot(w,q,'g')
plt.title('E(x) vs x')
plt.ylabel('Integral Values')
plt.xlabel('X Axis')
plt.show()